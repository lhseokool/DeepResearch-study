# 상태 관리 (State Management)

## 개요

DeepResearch는 계층별로 독립적인 State를 정의하여 각 Subgraph가 필요한 데이터만 관리하도록 설계되었습니다.

## State 계층 구조

```python
AgentState (Main Graph)
    ├─ messages: 사용자와의 대화
    ├─ supervisor_messages: Supervisor와의 대화
    ├─ research_brief: 연구 계획서
    ├─ notes: 압축된 연구 결과
    ├─ raw_notes: 원본 연구 데이터
    └─ final_report: 최종 보고서

SupervisorState (Supervisor Subgraph)
    ├─ supervisor_messages: Supervisor 대화
    ├─ research_brief: 연구 계획서
    ├─ notes: 수집된 연구 결과
    ├─ raw_notes: 원본 데이터
    └─ research_iterations: 반복 횟수

ResearcherState (Researcher Subgraph)
    ├─ researcher_messages: Researcher 대화
    ├─ research_topic: 연구 주제
    ├─ tool_call_iterations: 도구 호출 횟수
    ├─ compressed_research: 압축된 연구 결과
    └─ raw_notes: 원본 데이터
```

## State 정의

### 1. AgentState (메인 그래프)

```python
class AgentState(MessagesState):
    """메시지와 연구 데이터를 포함하는 메인 에이전트 상태."""
    
    # MessagesState에서 상속받은 messages 필드
    # messages: Annotated[list[MessageLikeRepresentation], add_messages]
    
    supervisor_messages: Annotated[list[MessageLikeRepresentation], override_reducer]
    research_brief: str | None
    raw_notes: Annotated[list[str], override_reducer] = []
    notes: Annotated[list[str], override_reducer] = []
    final_report: str
    compressed_research_length: int = 0
    raw_notes_length: int = 0
```

**주요 필드:**
- `messages`: 사용자와의 대화 기록 (자동 관리)
- `supervisor_messages`: Supervisor Subgraph와의 대화
- `research_brief`: 연구 계획서 (사용자 요청을 구조화)
- `notes`: 각 Researcher의 압축된 연구 결과
- `raw_notes`: 원본 연구 데이터 (압축 전)
- `final_report`: 최종 생성된 보고서

### 2. SupervisorState (감독자 서브그래프)

```python
class SupervisorState(TypedDict):
    """연구 작업을 관리하는 감독자를 위한 상태."""
    
    # Required
    supervisor_messages: Annotated[list[MessageLikeRepresentation], override_reducer]
    research_brief: str
    
    # Internal
    notes: Annotated[list[str], override_reducer] = []
    research_iterations: int = 0
    raw_notes: Annotated[list[str], override_reducer] = []
    compressed_research_length: int = 0
    raw_notes_length: int = 0
```

**주요 필드:**
- `supervisor_messages`: Supervisor의 대화 기록
- `research_brief`: 연구 계획서 (Main Graph에서 전달)
- `notes`: Researcher들로부터 수집한 연구 결과
- `research_iterations`: 연구 반복 횟수 (종료 조건 판단)

### 3. ResearcherState (연구자 서브그래프)

```python
class ResearcherState(TypedDict):
    """연구를 수행하는 개별 Researcher들을 위한 상태."""
    
    researcher_messages: Annotated[list[MessageLikeRepresentation], operator.add]
    tool_call_iterations: int = 0
    research_topic: str
    compressed_research: str
    raw_notes: Annotated[list[str], override_reducer] = []
```

**주요 필드:**
- `researcher_messages`: Researcher의 대화 기록 (도구 호출 포함)
- `research_topic`: 연구 주제 (Supervisor로부터 전달)
- `tool_call_iterations`: 도구 호출 횟수 (종료 조건 판단)
- `compressed_research`: 압축된 연구 결과 (출력)

### 4. ResearcherOutputState (연구자 출력)

```python
class ResearcherOutputState(BaseModel):
    """개별 Researcher들로부터의 출력 상태."""
    
    compressed_research: str
    raw_notes: Annotated[list[str], override_reducer] = []
```

**역할:**
- Researcher Subgraph의 출력 스키마 정의
- Supervisor가 받을 데이터 명시

## 커스텀 Reducer

### override_reducer

```python
def override_reducer(current_value, new_value):
    """상태에서 값을 덮어쓰기할 수 있도록 하는 리듀서 함수."""
    if isinstance(new_value, dict) and new_value.get("type") == "override":
        return new_value.get("value", new_value)
    else:
        return operator.add(current_value, new_value)
```

**사용 예시:**

```python
# 일반적인 추가
update = {"notes": ["새로운 노트"]}
# 결과: 기존 notes에 추가

# 덮어쓰기
update = {"notes": {"type": "override", "value": []}}
# 결과: notes를 빈 리스트로 초기화
```

**활용 사례:**
- `supervisor_messages`: Supervisor 대화 초기화 시
- `notes`: 최종 보고서 생성 후 정리 시
- `raw_notes`: 데이터 초기화 시

## State 업데이트 패턴

### 1. Command를 통한 업데이트

```python
return Command(
    goto="next_node",
    update={
        "research_brief": response.research_brief,
        "supervisor_messages": {
            "type": "override",
            "value": [
                SystemMessage(content=supervisor_system_prompt),
                HumanMessage(content=response.research_brief),
            ],
        },
    },
)
```

### 2. 딕셔너리 반환을 통한 업데이트

```python
return {
    "supervisor_messages": [response],
    "research_iterations": state.get("research_iterations", 0) + 1,
}
```

### 3. Subgraph 출력 자동 병합

```python
# Researcher Subgraph 실행
tool_results = await asyncio.gather(*research_tasks)

# 출력이 자동으로 SupervisorState에 병합됨
# compressed_research → notes에 추가
# raw_notes → raw_notes에 추가
```

## Input/Output Schema

### AgentInputState

```python
class AgentInputState(MessagesState):
    """InputState는 'messages'만 포함합니다."""
```

**역할:**
- Main Graph의 입력 스키마
- 사용자는 `messages`만 제공하면 됨

**사용 예시:**

```python
result = await deep_researcher.ainvoke({
    "messages": {"role": "user", "content": "AI 안전성 연구"}
})
```

## State 전달 흐름

```
1. User Input
   └─ AgentInputState: {"messages": [...]}

2. Main Graph
   ├─ AgentState 초기화
   └─ clarify_with_user → write_research_brief

3. Supervisor Subgraph 호출
   ├─ SupervisorState 생성 (research_brief 전달)
   └─ supervisor → supervisor_tools

4. Researcher Subgraph 호출 (병렬)
   ├─ ResearcherState 생성 (research_topic 전달)
   ├─ researcher → researcher_tools → compress_research
   └─ ResearcherOutputState 반환

5. Supervisor로 결과 병합
   └─ notes, raw_notes 업데이트

6. Main Graph로 결과 전달
   └─ notes, raw_notes 업데이트

7. Final Report
   └─ AgentState: {"final_report": "..."}
```

## 메모리 최적화

### 1. 상태 정리

```python
# 최종 보고서 생성 후 notes 정리
cleared_state = {"notes": {"type": "override", "value": []}}
return {
    "final_report": final_report.content,
    **cleared_state,
}
```

### 2. 메시지 절단

```python
# 토큰 제한 초과 시 메시지 제거
if is_token_limit_exceeded(e, model):
    researcher_messages = remove_up_to_last_ai_message(researcher_messages)
```

### 3. 압축 저장

```python
# 원본 데이터와 압축 데이터 모두 저장
return {
    "compressed_research": str(response.content),  # 압축된 버전
    "raw_notes": [raw_notes_content],              # 원본 데이터
}
```

## 모범 사례

1. **타입 안전성**: `Annotated`를 사용하여 Reducer 명시
2. **상태 격리**: 각 Subgraph는 필요한 데이터만 접근
3. **명시적 전달**: Subgraph 간 데이터는 명시적으로 전달
4. **정리 패턴**: 불필요한 데이터는 `override_reducer`로 정리
5. **추적 가능성**: `raw_notes`로 원본 데이터 보존
