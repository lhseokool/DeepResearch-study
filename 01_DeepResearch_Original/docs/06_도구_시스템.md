# 도구 시스템 (Tool System)

## 도구 계층 구조

```
Supervisor Tools
├─ ConductResearch (연구 위임)
├─ ResearchComplete (연구 완료)
└─ think_tool (전략적 사고)

Researcher Tools
├─ tavily_search (웹 검색)
├─ think_tool (전략적 사고)
├─ ResearchComplete (연구 완료)
└─ MCP Tools (외부 도구)
```

## 1. Supervisor 도구

### ConductResearch

```python
class ConductResearch(BaseModel):
    """특정 주제에 대한 연구를 수행하기 위해 이 도구를 호출합니다."""
    
    research_topic: str = Field(
        description="연구할 주제. 단일 주제여야 하며, 최소한 한 문단 정도로 상세하게 설명해야 합니다.",
    )
```

**역할:**
- Supervisor가 Researcher에게 연구 작업 위임
- 각 호출마다 독립적인 Researcher Subgraph 실행

**처리 로직:**

```python
conduct_research_calls = [
    tool_call for tool_call in most_recent_message.tool_calls
    if tool_call["name"] == "ConductResearch"
]

# 병렬 실행
research_tasks = [
    researcher_subgraph.ainvoke(
        {
            "researcher_messages": [HumanMessage(content=tool_call["args"]["research_topic"])],
            "research_topic": tool_call["args"]["research_topic"],
        },
        config,
    )
    for tool_call in allowed_conduct_research_calls
]
tool_results = await asyncio.gather(*research_tasks)
```

### ResearchComplete

```python
class ResearchComplete(BaseModel):
    """연구가 완료되었음을 나타내기 위해 이 도구를 호출합니다."""
```

**역할:**
- Supervisor가 연구 완료 신호
- 이 도구 호출 시 Supervisor Subgraph 종료

**처리 로직:**

```python
research_complete_tool_call = any(
    tool_call["name"] == "ResearchComplete" 
    for tool_call in most_recent_message.tool_calls
)

if research_complete_tool_call:
    return Command(goto=END, update={...})
```

## 2. Researcher 도구

### tavily_search

```python
@tool(description=TAVILY_SEARCH_DESCRIPTION)
async def tavily_search(
    queries: list[str],
    max_results: Annotated[int, InjectedToolArg] = 5,
    topic: Annotated[Literal["general", "news", "finance"], InjectedToolArg] = "general",
    config: RunnableConfig = None,
) -> str:
    """Fetch and summarize search results from Tavily search API."""
```

**기능:**
1. 여러 검색 쿼리 병렬 실행
2. 검색 결과 중복 제거
3. 웹페이지 콘텐츠 요약
4. 포맷된 결과 반환

**구현 상세:**

```python
async def tavily_search(queries, max_results, topic, config):
    # 1. 검색 실행
    search_results = await tavily_search_async(queries, max_results, topic, ...)
    
    # 2. URL 기반 중복 제거
    unique_results = {}
    for response in search_results:
        for result in response["results"]:
            if result["url"] not in unique_results:
                unique_results[result["url"]] = result
    
    # 3. 웹페이지 요약 (병렬)
    summarization_tasks = [
        summarize_webpage(summarization_model, result["raw_content"][:max_char])
        for result in unique_results.values()
    ]
    summaries = await asyncio.gather(*summarization_tasks)
    
    # 4. 결과 포맷
    formatted_output = "Search results: \n\n"
    for i, (url, result) in enumerate(summarized_results.items()):
        formatted_output += f"\n\n--- SOURCE {i + 1}: {result['title']} ---\n"
        formatted_output += f"URL: {url}\n\n"
        formatted_output += f"SUMMARY:\n{result['content']}\n\n"
    
    return formatted_output
```

### 웹페이지 요약

```python
async def summarize_webpage(model: BaseChatModel, webpage_content: str) -> str:
    """AI 모델을 사용하여 웹페이지 콘텐츠를 요약합니다."""
    try:
        summary = await asyncio.wait_for(
            model.ainvoke([HumanMessage(content=prompt_content)]),
            timeout=60.0,
        )
        
        formatted_summary = (
            f"<summary>\n{summary.summary}\n</summary>\n\n"
            f"<key_excerpts>\n{summary.key_excerpts}\n</key_excerpts>"
        )
        return formatted_summary
    
    except TimeoutError:
        return webpage_content  # 타임아웃 시 원본 반환
```

## 3. think_tool

```python
@tool(description="Strategic reflection tool for research planning")
def think_tool(reflection: str) -> str:
    """Tool for strategic reflection on research progress and decision-making."""
    return f"Reflection recorded: {reflection}"
```

**역할:**
- 연구 진행 상황 분석
- 다음 단계 계획
- 의사결정 과정 가시화

**사용 시점:**
- 검색 결과 분석 후
- 다음 검색 계획 전
- 연구 완료 판단 시

**프롬프트 가이드:**

```python
research_system_prompt = """
<Show Your Thinking>
After each search tool call, use think_tool to analyze the results:
- What key information did I find?
- What's missing?
- Do I have enough to answer the question comprehensively?
- Should I search more or provide my answer?
</Show Your Thinking>
"""
```

## 4. MCP 도구 통합

### MCP 도구 로드

```python
async def load_mcp_tools(config: RunnableConfig, existing_tool_names: set[str]) -> list[BaseTool]:
    # 1. 인증 처리
    if configurable.mcp_config and configurable.mcp_config.auth_required:
        mcp_tokens = await fetch_tokens(config)
    
    # 2. MCP 서버 연결
    mcp_server_config = {
        "server_1": {
            "url": server_url,
            "headers": auth_headers,
            "transport": "streamable_http"
        }
    }
    client = MultiServerMCPClient(mcp_server_config)
    available_mcp_tools = await client.get_tools()
    
    # 3. 도구 필터링 및 래핑
    configured_tools = []
    for mcp_tool in available_mcp_tools:
        if mcp_tool.name in set(configurable.mcp_config.tools):
            enhanced_tool = wrap_mcp_authenticate_tool(mcp_tool)
            configured_tools.append(enhanced_tool)
    
    return configured_tools
```

### MCP 인증 래퍼

```python
def wrap_mcp_authenticate_tool(tool: StructuredTool) -> StructuredTool:
    """MCP 도구에 인증 및 오류 처리 추가"""
    original_coroutine = tool.coroutine
    
    async def authentication_wrapper(**kwargs):
        try:
            return await original_coroutine(**kwargs)
        except BaseException as original_error:
            mcp_error = _find_mcp_error_in_exception_chain(original_error)
            if mcp_error and mcp_error.error.code == -32003:  # Interaction required
                raise ToolException(error_message) from original_error
            raise original_error
    
    tool.coroutine = authentication_wrapper
    return tool
```

## 5. 도구 조합

### get_all_tools

```python
async def get_all_tools(config: RunnableConfig):
    """연구, 검색, MCP 도구를 포함한 완전한 도구 키트를 조립합니다."""
    
    # 1. 핵심 연구 도구
    tools = [tool(ResearchComplete), think_tool]
    
    # 2. 검색 도구 추가
    configurable = Configuration.from_runnable_config(config)
    search_api = SearchAPI(get_config_value(configurable.search_api))
    search_tools = await get_search_tool(search_api)
    tools.extend(search_tools)
    
    # 3. MCP 도구 추가
    existing_tool_names = {
        tool.name if hasattr(tool, "name") else tool.get("name", "web_search") 
        for tool in tools
    }
    mcp_tools = await load_mcp_tools(config, existing_tool_names)
    tools.extend(mcp_tools)
    
    return tools
```

### 검색 API 선택

```python
async def get_search_tool(search_api: SearchAPI):
    if search_api == SearchAPI.OPENAI:
        # OpenAI 네이티브 웹 검색
        return [{"type": "web_search_preview"}]
    
    elif search_api == SearchAPI.TAVILY:
        # Tavily 검색 도구
        search_tool = tavily_search
        search_tool.metadata = {
            "type": "search",
            "name": "web_search",
        }
        return [search_tool]
    
    elif search_api == SearchAPI.NONE:
        return []
```

## 6. 도구 실행 패턴

### 안전한 실행

```python
async def execute_tool_safely(tool, args, config):
    """오류 처리를 포함하여 도구를 안전하게 실행합니다."""
    try:
        return await tool.ainvoke(args, config)
    except Exception as e:
        return f"Error executing tool: {str(e)}"
```

### 병렬 실행

```python
# 모든 도구 호출을 병렬로 실행
tool_calls = most_recent_message.tool_calls
tool_execution_tasks = [
    execute_tool_safely(tools_by_name[tool_call["name"]], tool_call["args"], config)
    for tool_call in tool_calls
]
observations = await asyncio.gather(*tool_execution_tasks)

# 결과를 ToolMessage로 변환
tool_outputs = [
    ToolMessage(content=observation, name=tool_call["name"], tool_call_id=tool_call["id"])
    for observation, tool_call in zip(observations, tool_calls, strict=True)
]
```

## 7. 네이티브 웹 검색 감지

### OpenAI 웹 검색

```python
def openai_websearch_called(response):
    """OpenAI의 웹 검색 기능이 사용되었는지 감지"""
    tool_outputs = response.additional_kwargs.get("tool_outputs")
    if not tool_outputs:
        return False
    
    for tool_output in tool_outputs:
        if tool_output.get("type") == "web_search_call":
            return True
    
    return False
```

### Anthropic 웹 검색

```python
def anthropic_websearch_called(response):
    """Anthropic의 네이티브 웹 검색이 사용되었는지 감지"""
    try:
        usage = response.response_metadata.get("usage")
        server_tool_use = usage.get("server_tool_use")
        web_search_requests = server_tool_use.get("web_search_requests")
        return web_search_requests > 0
    except (AttributeError, TypeError):
        return False
```

## 8. 도구 메타데이터

### InjectedToolArg

```python
@tool
async def tavily_search(
    queries: list[str],
    max_results: Annotated[int, InjectedToolArg] = 5,  # LLM이 제공하지 않음
    topic: Annotated[Literal["general", "news", "finance"], InjectedToolArg] = "general",
    config: RunnableConfig = None,  # 자동 주입
) -> str:
    """검색 도구"""
```

**InjectedToolArg 사용 이유:**
- LLM이 제공할 필요 없는 인자
- 런타임 설정값 자동 주입
- 도구 시그니처 단순화

### 도구 메타데이터

```python
search_tool = tavily_search
search_tool.metadata = {
    "type": "search",
    "name": "web_search",
}
```
