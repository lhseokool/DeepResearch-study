# 최적화 및 모범 사례

## 1. 성능 최적화

### 병렬 처리 최대화
```python
# 독립적인 연구는 병렬로
max_concurrent_research_units = 5

# 도구 호출도 병렬로
tool_execution_tasks = [
    execute_tool_safely(tool, args, config)
    for tool_call in tool_calls
]
observations = await asyncio.gather(*tool_execution_tasks)
```

### 조기 종료
```python
# 충분한 정보 수집 시 조기 종료
if exceeded_iterations or research_complete_called:
    return Command(goto="compress_research")
```

## 2. 비용 최적화

### 모델 선택
```python
# 간단한 작업: 저렴한 모델
summarization_model = "openai:gpt-4.1-mini"
compression_model = "openai:gpt-4.1-mini"

# 복잡한 작업: 고성능 모델
research_model = "openai:gpt-4.1"
final_report_model = "openai:gpt-4.1"
```

### 도구 호출 제한
```python
max_react_tool_calls = 10  # Researcher 도구 호출 제한
max_researcher_iterations = 6  # Supervisor 반복 제한
```

## 3. 품질 최적화

### 프롬프트 개선
- 명확한 지침
- 구체적인 예시
- 제약 조건 명시

### 검증 강화
```python
.with_structured_output(ClarifyWithUser)
.with_retry(stop_after_attempt=3)
```

## 4. 디버깅

### 상태 추적
```python
return {
    "research_iterations": state.get("research_iterations", 0) + 1,
    "compressed_research_length": len(compressed_research),
}
```

### 로깅
```python
logging.warning(f"60초 후 요약 타임아웃")
logging.error(f"토큰 교환 실패: {response_text}")
```

## 5. 확장성

### MCP 도구 추가
```python
mcp_config = {
    "url": "https://mcp-server.com",
    "tools": ["custom_tool_1", "custom_tool_2"],
    "auth_required": True,
}
```

### 커스텀 검색 API
```python
async def get_search_tool(search_api: SearchAPI):
    if search_api == SearchAPI.CUSTOM:
        return [custom_search_tool]
```
